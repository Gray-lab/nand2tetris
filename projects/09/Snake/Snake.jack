// Represents the user-controlled snake object
// Needs to have a direction and a length
// Also controls the rendering of the snake and intersection behaviour

/** Implements a snake for the game snake
The snake has 4 movement directions
Can cross across the borders of the screen
It is able to grow
And it dies if it intersects itself

An interesting problem is setting this up so that the time at each step
stays the same even as the snake gets longer! We need to set up the snake so that 
as many operations as possible are constant time, otherwise the game will slow down
as the snake gets longer. This is relatively easy to do
when drawing the snake, but is harder when checking for intersection.
To make intersection checks constant time, a hash table would have to be used.
*/
class Snake {
  field Segment head; // head of the snake, poiting to null
  field Segment tail; // tail of the snake, pointing to a Segment towards the head
  field int gridSize; // size of a block of the snake
  
  /** Constructs a new snake */
  constructor Snake new(int Ly, int Lx, int gameGridSize) {
    let gridSize = gameGridSize;
    let head = Segment.new(Lx, Ly);
    let tail = Segment.new(Lx - gridSize, Ly);
    // set prev pointer from tail to head
    do tail.setPrev(head);
    // draw both segments
    do draw(head);
    do draw(tail);
    return this;
  }

  method void step(int direction, boolean grow) {
    // every time we step, we want to 
    // 1. add a new segment to the front and draw it
    var Segment newSeg;
    var Segment tempSeg;
    var Segment next;
    if (direction = 1) { let newSeg = Segment.new(head.getX(), head.getY() - gridSize); }
    if (direction = 2) { let newSeg = Segment.new(head.getX() + gridSize, head.getY()); }
    if (direction = 3) { let newSeg = Segment.new(head.getX(), head.getY() + gridSize); }
    if (direction = 4) { let newSeg = Segment.new(head.getX() - gridSize, head.getY()); }
    do head.setPrev(newSeg);
    let head = newSeg;
    do draw(head);   
    // 2. if not growing, delete the segment at the back and remove it
    if (~grow) {
      do erase(tail);
      let tempSeg = tail.getPrev();
      do tail.dispose();
      let tail = tempSeg;
    }
    do Sys.wait(100);
    return;
  }

  /** dispose recursively starting with tail */
  method void dispose() {
    var Segment prevTail;
    if (~(tail.getPrev() = null)) {
      let prevTail = tail.getPrev();
      do prevTail.dispose();
    }
    do Memory.deAlloc(this);
    return;
  }

  /** draws the snake on the screen. We need to keep track of past positions
  so that the elements of the snake follow the head */
  method void draw(Segment segment) {
    var int x;
    var int y;
    let x = segment.getX();
    let y = segment.getY();
    do Screen.setColor(true);
    //do Output.printInt(x);
    //do Output.printString(",");
    //do Output.printInt(y);
    //do Output.printString(",");
    //do Output.printInt(gridSize);
    //do Output.println();
    //do Output.printString("About to draw rectangle");
    do Screen.drawRectangle(x+1, y+1, x + gridSize-1, y + gridSize-1);
    return;
  }

  method void erase(Segment segment) {
    var int x;
    var int y;
    let x = segment.getX();
    let y = segment.getY();
    do Screen.setColor(false);
    do Screen.drawRectangle(x+1, y+1, x + gridSize-1, y + gridSize-1);
    return;
  }
}
  
